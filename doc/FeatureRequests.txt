List of features that we hope to add to Ziria at some point:

- More graceful automatic type casting. For example, x_int32 + x_int16 should automatically result 
  into y_int32 and not error.

- Support constant expressions wherever a literal is expected (e.g. var x:arr[const] int 
  and a[0,const] := b[0,const] and x<-takes const).

- Correct file and line number reporting on errors consistently through Ziria. 
  For example, bounds checking only reports line number from the expanged file.
  Type checking seems to also report a line number from the expanded file. 

- Array sizes are dynamically bound in function input but not in function output. 
  It seems that we cannot declare a function that return an array of unspecified size. 

- Implement static initialization of a complex array with a constant array.

- This is actually a bug. The following: 
      int8_to_bits(x[24+i*8,8], arr_cnt[0,1]);
  will create a subarray bitarrresXX using bitArrRead, call the external function on it
  but never really write it back to x!

- Fix the bug in typeinfer.wpl test in backend

- Fix the bug in stateinit.wpl test in backend

- Fix the heap bug in struct3.wpl test in backend

- Add switch/case statement

- Statically evaluated code that will be evaluated from a separate high-level function call. 
  For example, we can call from an outer C code: { init(); while(1){ run() }};
  So that we can reenter the pipeline from C (MAC code) with minimum reinitialization cost.

- Restructure various calls from Ziria generated code to make the API more clear. 
  For example, wpl_global_init() initializes the heap using wpl_init_heap and generates LUTs.
  So if I want to run wpl_go() many times in a C loop, I need to do only one one global init
  but I need to run wpl_init_heap in each loop. This should be simplified and clarified.

- Better return of parameters between MAC(C) and PHY(Ziria). For example, if Ziria code is a
  computer that returns a struct, this struct should be returned by wpl_go. Also, allow MAC 
  to quuery Ziria's compile-time parameters, such as input/output types.

- Make letRef work with constant array. For example, allow: let A = {1,2,3,4} in

- Allow to define let functions within Expr language. At the moment we can only
  define them in computational language.

- Error message for missing argument is not informative. For example, if function is defined
  to have two arguments (e.g. f(a,b)) and I call it with one f(a), I get:
     rx.blk
     "rx.blk" (line 42, column 45):
     unexpected ")"
     expecting letter or digit, ".", "[", operator or ","
     ExitFailure 1
     Makefile:49: recipe for target 'rx.c' failed
  whereas it should have told me that I failed to supply the second argument.
  But I have also see instances where a similar error message was reported correctly.

- This kind of programs:
    let a = {25, 29, 34} in 
    let b = a[n] in ...
  gives weird compilation error:
    Prelude.(!!): index too large

- print array function is inefficient when applied on function that returns an array. 
  Consider println pss(3), where pss(3) :: Int -> Arr[62] Int
  The code generated by Ziria is:
            for (int __print_cnt_96 = 0; __print_cnt_96 < 62;
                 __print_cnt_96++) {
                calign complex16 __print_val_97;
                
                mem_idx99 = wpl_get_free_idx(pheap_ctx);
                pss_ln6_81(__retcall_pss_ln7_98, 62, 3, 1000, &pi_ln34_4);
                wpl_restore_free_idx(pheap_ctx, mem_idx99);
                __print_val_97 = __retcall_pss_ln7_98[__print_cnt_96];
                printf("(%ld,%ld)", __print_val_97.re, __print_val_97.im);
                printf("%s", ",");
            }
  So we actually call pss function 62 times in this case! (which is potentially also incorrect).

- Add enumerate types

- Add constant size arrays with variable values. For example,
    let y = {x1, x2} in 
  currently does not compile, but seems to have very clean sematics: 
    var tmp:arr[2] : int;
    tmp[0] := x1; tmp[1] := x2; 
    let y = tmp

- Add int8_to_bit and bit_to_int8 conversion as a language operator. 
  For example, int8_to_bit(7) should return {'0, '1, '1, '1} bit array. 
  It is beneficial to have this in a language as it is a simple and frequently used
  operation, so it is worth doing it efficiently.

- Add a compiler switch to change endianness of bit operations







