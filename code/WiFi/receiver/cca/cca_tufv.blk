-- 
-- Copyright (c) Microsoft Corporation
-- All rights reserved. 
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http://www.apache.org/licenses/LICENSE-2.0
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--
#include <externals.blk> 
#include <v_correlate.blk>
#include <abs.blk>
#include <conj.blk>
#include "../../const.blk"



-- NOTE: CCA_Tuffveson is not real time on Dell T3500. Currently, 
-- with CORR_LEN == 8 it takes 1.7s to process 20e samples 
-- (which should be done in 1s). This should be further optimized
-- for line speed.

#define CORR_LEN         8
#define NO_REP          ((160/CORR_LEN)-1)

#define MAX_CORR_HIST   (256/CORR_LEN)
#define MAX_CORR_THR    5


-- Use this define to debug CCA output after every input read
--#define CCA_TUFV_DEBUG_OUTPUT
-- Uncomment to plot outputs using test_cca
--#define CCA_DEBUG_PLOT

-- Measured to PC in bozidar's office on the 1st floor
-- iEnergy: idle=260, Sora12 sine: 13k, Sora12 pkt: 4k, Sora MSR roof sine: 1k, Sora MSR pkt: 400
-- maxCorr: idle: 16k, Sora12 sine: 400k, Sora12 pkt: 70k, Sora MSR roof sine: 30k, Sora MSR pkt: 22k



#ifdef MAC
   let external MAC_cca_read() : int32 in
#endif


let norm_shift = 7 in 
--let no_consec_increases = 4 in
let no_consec_increases = NO_REP/2 in


-- Same as in transmitter/createPreamble, except that it is at a lower sampling rate
fun createSTSinTime() {
  var sts : arr[64] complex16;
  var sts_time : arr[320] complex16;

  let sts_mod = int16(double(bpsk_mod_11a) * 1.472) 

  -- Reset everything - otherwise we might have an ambiguous preamble
  zero_complex16(sts);

  -- short training symbol
  sts[4]   := complex16{re=-sts_mod; im=-sts_mod};
  sts[8]   := complex16{re=-sts_mod; im=-sts_mod};
  sts[12]  := complex16{re=sts_mod; im=sts_mod};
  sts[16]  := complex16{re=sts_mod; im=sts_mod};
  sts[20]  := complex16{re=sts_mod; im=sts_mod};
  sts[24]  := complex16{re=sts_mod; im=sts_mod};

  sts[40] := complex16{re=sts_mod; im=sts_mod};
  sts[44] := complex16{re=-sts_mod; im=-sts_mod};
  sts[48] := complex16{re=sts_mod; im=sts_mod};
  sts[52] := complex16{re=-sts_mod; im=-sts_mod};
  sts[56] := complex16{re=-sts_mod; im=-sts_mod};
  sts[60] := complex16{re=sts_mod; im=sts_mod};

  sts_time[0, 64] := sora_ifft(sts);
  sts_time[64,64] := sts_time[0,64];
  sts_time[128,32] := sts_time[0,32];

  return sts_time;
} in


fun InitCorrPattern() {
  var pattern : arr[CORR_LEN*CORR_LEN] complex16;
  var preamble : arr[64] complex16;


  -- let sts = createSTSinTime()  
  let sts = createSTSinTime()  
  for i in [0, 64] {
    preamble[i] := sts[i];
  };

  v_shift_right_complex16(preamble, preamble, norm_shift);

  -- cyclic shift - stores all possible preamble shifts of length 16 in the pattern
  for i in [0,CORR_LEN] {
    pattern[i*CORR_LEN, CORR_LEN] := preamble[i,CORR_LEN];
  }

  return pattern;
} in



-- Detection using Tufvesson algorithm
-- Tufvesson et al, Time and Frequency Synchronization using PN-Sequence Preambles, VTC 99

fun comp cca() {
   var pattern : arr[CORR_LEN*CORR_LEN] complex16;
   var corr : int32;
   var maxCorr : int32;
   var maxInd : int16;   
   var input : arr[CORR_LEN] complex16;
   var mul_hist : arr[CORR_LEN*CORR_LEN] complex32;
   var corr_hist : arr[NO_REP*CORR_LEN] int32;
   var max_corr_hist : arr[MAX_CORR_HIST] int32;
   var oldOldCorr : int32 := 0;
   var oldCorr : int32 := 0;
   var oldInd : int16 := 0;
   var oldOldInd : int16 := 0;
   var noInc : int16 := 0;
   var detected : bool := false; 
   var timeout : bool := false; 
   var iterind : int32 := 0;

   -- calcEnergy related
   var gesw : arr[4] int;
   var iEnergy : int := 0;
   var iNoise : int := 0;
   var initial_idle : bool := false;
   var idle_cnt : int := 0;

   -- return param
   var ccaTimeout : int32;
   var ret : struct CCAParams;

   -- DEBUG
   var debCorr : int32;
   var debCorr2 : int32;



   fun calcEnergy(x : arr complex16) {
     var ge : int;
     var xcopy:arr[length(x)] complex16;
     var iEnergy : int := 0;
     var re32:arr[length(x)] int32;
     var im32:arr[length(x)] int32;

     v_shift_right_complex16(xcopy,x,2);
     v_shift_right_complex16(xcopy,xcopy,2);

     v_conj_mul_complex16_int32(re32, im32, xcopy, xcopy);
     iEnergy := v_sum_int32(re32);
     return (iEnergy)
   };




   do {
#ifdef MAC
      ccaTimeout := MAC_cca_read();
#else
      ccaTimeout := 2000000000;
#endif
      pattern := InitCorrPattern();
      zero_int32(corr_hist);
      zero_complex32(mul_hist);
      zero_int32(gesw);
      for i in [0, MAX_CORR_HIST] {
        -- Not too close to saturation!
        max_corr_hist[i] := 1000000;
      }
      iterind := 0;
   }




#ifndef CCA_TUFV_DEBUG_OUTPUT
   until (detected == true || timeout == true) {
     x <- takes CORR_LEN;

     do {

       v_shift_right_complex16(input, x, norm_shift);

       iEnergy := calcEnergy(x);      

       if (iterind == 1000) then {
         iNoise := iEnergy;
       }

       maxCorr := 0;
       for i in [0, CORR_LEN] {
          let corrc = v_correlate(pattern[i*CORR_LEN,CORR_LEN], input) 
          let corrmul = corrc * conj_complex32(mul_hist[i])  
          let corri = (abs_int32(corrmul.re) + abs_int32(corrmul.im))  
          mul_hist[i] := corrc;

          corr_hist[i*NO_REP,NO_REP-1] := corr_hist[i*NO_REP+1,NO_REP-1];
          corr_hist[i*NO_REP+NO_REP-1] := corri;

          corr :=0;
          for j in [0,NO_REP] {
            corr := corr + corr_hist[i*NO_REP+j];
          }

          if (corr > maxCorr) then {
             maxCorr := corr;
             debCorr := corri;
             maxInd := int16(i);
          }
       }
       -- Because of repeating preamble we should have a certain number of consecutive 
       -- increases before declaring the peak - start of a packet
       -- Also, we check that the energy has increased by comparing the peak with 
       -- the one MAX_CORR_THR rounds before - it has to be substantially larger because:
       -- (a) packet has started and the energy increased
       -- (b) preamble detection is coherent and noise is non-coherent
       if (maxCorr > MAX_CORR_THR * max_corr_hist[MAX_CORR_HIST-1]
           && noInc > no_consec_increases 
           && (oldCorr > maxCorr || oldInd != maxInd)) then {
          detected := true;
       }

       if (oldOldCorr < oldCorr && oldCorr < maxCorr && oldOldInd == oldInd && oldInd == maxInd) then {
          noInc := noInc + 1;
       } else {
          noInc := 0;
       }

       -- DEBUG
       debCorr2 := max_corr_hist[MAX_CORR_HIST-1];

       max_corr_hist[1, MAX_CORR_HIST-1] := max_corr_hist[0, MAX_CORR_HIST-1];
       max_corr_hist[0] := maxCorr;


       oldOldCorr := oldCorr;
       oldCorr := maxCorr;
       oldOldInd := oldInd;
       oldInd := maxInd;

       iterind := iterind + 1;


#ifdef MAC
       if (iterind > ccaTimeout) then {
         timeout := true;
       }
#endif

     }


#else
   -- DEBUG code used to debug every output of correlator

   until detected == true {
     x <- takes CORR_LEN;

     do {
       v_shift_right_complex16(input, x, norm_shift);
       iEnergy := calcEnergy(x);      
       maxCorr := 0;
     }

     for i in [0, CORR_LEN] {
        do{
          let corrc = v_correlate(pattern[i*CORR_LEN,CORR_LEN], input) 
          let corrmul = corrc * conj_complex32(mul_hist[i])  
          -- let corrmul = corrc 
          let corri = (abs_int32(corrmul.re) + abs_int32(corrmul.im))  
          mul_hist[i] := corrc;

          corr_hist[i*NO_REP,NO_REP-1] := corr_hist[i*NO_REP+1,NO_REP-1];
          corr_hist[i*NO_REP+NO_REP-1] := corri;

          corr :=0;
          for j in [0,NO_REP] {
            corr := corr + corr_hist[i*NO_REP+j];
          }

          if (corr > maxCorr) then {
             maxCorr := corr;
             debCorr := corri;
             maxInd := int16(i);
          }

          debCorr := corri;
          debCorr2 := corr;

       }


#ifdef CCA_DEBUG_PLOT
       emit iEnergy;
#else
       emit debCorr;
--       emit debCorr2;
       emit iEnergy;
       emit maxCorr;
#endif

    }
    do{
       -- Because of repeating preamble we should have a certain number of consecutive 
       -- increases before declaring the peak - start of a packet
       if (maxCorr > MAX_CORR_THR * max_corr_hist[MAX_CORR_HIST-1]
           && noInc > no_consec_increases 
           && (oldCorr > maxCorr || oldInd != maxInd)) then {
#ifdef CCA_DEBUG_PLOT
-- DEBUG (we ignore detections in debug mode to be able to plot it all)
          detected := false;
#else
          detected := true;
#endif
       }

       if (oldOldCorr < oldCorr && oldCorr < maxCorr && oldOldInd == oldInd && oldInd == maxInd) then {
          noInc := noInc + 1;
       } else {
          noInc := 0;
       }

       max_corr_hist[1, MAX_CORR_HIST-1] := max_corr_hist[0, MAX_CORR_HIST-1];
       max_corr_hist[0] := maxCorr;

       oldOldCorr := oldCorr;
       oldCorr := maxCorr;
       oldOldInd := oldInd;
       oldInd := maxInd;

       iterind := iterind + 1;
    }
#endif    




{-
     emit maxCorr;
     emit int32(noInc);
     emit debCorr2;
--     emit int32(maxInd);
     emit iEnergy;
-}

   }

  do {
    ret.noSamples := (16*iterind + int(oldInd));
    ret.shift := oldInd;
    ret.energy := iEnergy;
    ret.noise := iNoise;
    ret.maxCorr := maxCorr;
    ret.timeout := timeout;
  };

  return ret;

} in








