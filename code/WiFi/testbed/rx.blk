#define LTS_ACCURATE
--#define RADIO
#define DO_DECODING
--#define FAST

#define MAC                     -- USe this to exit CCA after a timeout



#include <externals.blk>
#include "../const.blk"
#include "../receiver/cca/cca_tufv.blk"
#include "../receiver/OFDM/LTS.blk"
#include "../receiver/removeDC.blk"
#include "../receiver/OFDM/DataSymbol.blk"
#include "../receiver/OFDM/FreqCompensation.blk"
#include "../receiver/OFDM/FFT.blk"
#include "../receiver/OFDM/ChannelEqualization.blk"
#include "../receiver/OFDM/PilotTrack.blk"
#include "../receiver/OFDM/GetData.blk"

#ifdef DO_DECODING
#include "../receiver/decoding/DecodePLCP.blk"
#include "../receiver/decoding/Decode.blk"
#include "../transmitter/crc.blk"
#endif


-- External function to return parameters to MAC
let external MAC_cca_write(energy : int32, noise : int32, detected : bool) : () in




fun comp detectPreamble() {
  (removeDC() >>> cca())
} in 



#ifdef DO_DECODING
fun comp processCRC(hdata : struct HeaderInfo) {
var retCRC: arr[8] bit; 
var retMod: arr[8] bit; 
var retEnc: arr[8] bit; 
var retSize: arr[16] bit; 
var tmp: arr[2] int8;

  (c : arr[4] bit) <- crc(hdata.len, false); 
  crc <- check_crc(c);

  -- The following sends packet data to MAC
  do {
     -- CRC
     if (crc) then {
        tmp[0] := 1;
     } else {
        tmp[0] := 0;
     }
     int8_to_bits(retCRC, tmp[0,1]);

     -- Modulation
     tmp[0] := int8(hdata.modulation);
     int8_to_bits(retMod, tmp[0,1]);

     -- Coding
     tmp[0] := int8(hdata.coding);
     int8_to_bits(retEnc, tmp[0,1]);

     -- Size
     tmp[0] := int8(hdata.len % 256);
     tmp[1] := int8(hdata.len / 256);
     int8_to_bits(retSize, tmp[0,2]);
  } 
  emits retCRC;
  emits retMod;
  emits retEnc;
  emits retSize;
} in

fun comp receiveBits() {
var cnt : int := 0;
       seq { hdata <- DecodePLCP()
           ; Decode(hdata) >>> processCRC(hdata)
           }
} in
#endif




fun comp pad() {
  times 500 {
    emit complex16{re=0; im=0};
  };
  repeat{
    x<-take;
    emit x;
  }
} in



fun comp skip() {
  times 1 {
     take;
  };

  repeat {
    x<- take;
    emit x;
  }  
} in






fun comp amp() {
repeat{
  (x : complex16) <- take;
  let const = 1;
  emit complex16{re = x.re * const; im = x.im * const};
  --emit complex16{re = x.re / const; im = x.im / const};
}
} in


{-
read[complex16] >>> 
   times 10000 {x<-take; emit x}
>>> write
-}



{-
read[complex16] >>> 
  skip() >>>
  {det <- detectPreamble()
        ; do{println "Detected at: ", det.noSamples, ", shift: ", det.shift, 
                     ", energy: ", det.energy, ", noise: ", det.noise, ", maxCorr: ", det.maxCorr}
  }
>>> write
-}



{- LINE SPEED TEST
fun comp test() {
var cnt : int32 := 0;
var detected : bool := false;
  until (detected) {
    x <- takes 16;
    do{
      cnt := cnt + 1;
      if (cnt >= 125000) then {
        detected := true;
      }
    }
  }
} in 
read[complex16] >>> test() >>> write[int]
-}


{-
read >>> { det <- detectPreamble()
         ; do{MAC_cca_write(det.energy, det.noise, not det.timeout)}
         } >>> write [int]
-}



---- BOZIDAR: Slow code
read >>> 
       seq{ det<-detectPreamble()
          ; if (not det.timeout) then {
              do {println "HEYS: ", det.timeout};
              -- BOZIDAR: Remove the line below to get it fast
              params <- (LTS(det.shift, det.maxCorr));
              do {println "HEY: ", det.timeout};
            }
          }
   >>> write[int]



---- BOZIDAR: Fast code
{-
read >>> 
       seq{ det<-detectPreamble()
          ; emit 0
          }
   >>> write[int]
-}



{-
-- No repeat here, it happens at the MAC level
   read >>> 
#ifndef RADIO 
   repeat{
#endif
       seq{ det<-detectPreamble()
          ; do{MAC_cca_write(det.energy, det.noise, not det.timeout)}
       #ifndef FAST
          ; do{println "Detected at: ", det.noSamples, ", shift: ", det.shift, 
                       ", energy: ", det.energy, ", noise: ", det.noise, ", maxCorr: ", det.maxCorr}
       #endif
          ; if (not det.timeout) then {
              params <- (LTS(det.shift, det.maxCorr));
              DataSymbol(det.shift) 
                >>> FFT() 
                >>> ChannelEqualization(params)
                >>> PilotTrack() 
                >>> GetData()
              #ifdef DO_DECODING
                >>> receiveBits()
              #endif
            }
          }
#ifndef RADIO 
   }
#endif
   >>> write
-}
