# 1 "test_tx_header.blk"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "test_tx_header.blk"
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--

-- Test created using Annex G, IEEE Standard_802.11a-1999

# 1 "../parsePLCPHeader.blk" 1
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--
       

# 1 "/cygdrive/c/Users/t-stsmo/src/Ziria/lib/externals.blk" 1
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--
       

-- Trigonometry

fun external arctan2(y:int16, x: int16, th:arr[1] int16) : ()
fun external ucosw(y:int16, out:arr[1] int16) : ()
fun external usinw(y:int16, out:arr[1] int16) : ()
fun external sin_int16(x:int16) : int16
fun external cos_int16(x:int16) : int16
fun external atan2_int16(y:int16, x:int16) : int16
fun external atan2_int32(y:int32, x:int32) : int32


-- ext_math
let pi = 3.1415926536
fun external sine_double_int16(x:int16, prec:int16) : int16
fun external sine_double_int32(x:int32, prec:int32) : int32
fun external cosine_double_int16(x:int16, prec:int16) : int16
fun external cosine_double_int32(x:int32, prec:int32) : int32

fun external imin_int16(x:int16, y:int16) : int16
fun external imin_int32(x:int, y:int) : int
fun external imax_int16(x:int16, y:int16) : int16
fun external imax_int32(x:int, y:int) : int

fun external ceil_int16(d:double) : int16
fun external ceil_int32(d:double) : int32
fun external round_int16(d:double) : int16
fun external round_int32(d:double) : int32

fun external log2(d:double) : double
fun external log2_int16(d:int16) : int16
fun external log2_int32(d:int32) : int32

fun external sqrt(d:double) : double
fun external sqrt_int16(d:int16) : int16
fun external sqrt_int32(d:int32) : int32



-- SIMD
-- Downsample input by 2
fun external v_downsample_complex16(input:arr complex16) : arr[length(input)] complex16;

fun external permutate_low1032w (x:arr[4] complex16, y:arr[4] complex16): ()
fun external permutate_high1032w (x:arr[4] complex16, y:arr[4] complex16): ()
fun external pairwise_muladdw (x:arr[4] complex16, y:arr[4] complex16, z:arr[4] int): ()
fun external conjrew (x:arr[4] complex16, y:arr[4] complex16): ()
fun external sum_conj_mulw32 (x:arr[4] complex16, y:arr[4] complex16): complex

-- Return by reference for performance
--fun external conj0w (x:arr[4] complex16): arr[4] complex16
--fun external muladdw (a:arr[4] complex16, b:arr[4] complex16): arr[4] int
--fun external conj_mulw (x:arr[4] complex16, y:arr[4] complex16): arr[4] complex16
fun external conj0w (ret:arr[4] complex16, x:arr[4] complex16): ()
fun external muladdw (ret:arr[4] int, a:arr[4] complex16, b:arr[4] complex16): ()
fun external conj_mulw (ret:arr[4] complex16, x:arr[4] complex16, y:arr[4] complex16): ()


-- CHECK, unify, and make inputs polymorphic
fun external sumc16 (x:arr[4] complex16): complex16
fun external sumc32 (x:arr[4] complex): complex
fun external sumi16 (x:arr[4] int16): int16
fun external sumi32 (x:arr[4] int): int
fun external v_sum_complex16(x:arr complex16 ) : complex16
fun external v_sum_int32(x:arr int32 ) : int32


-- equivalent to sora hadd:
-- Sum all components of vector x and stores it in all components of z
-- z(i) = sum(x) for all i
fun external v_hadd_complex16(z:arr[4] complex16, x:arr[4] complex16) : ()
fun external v_hadd_int32(z:arr[4] int, x:arr[4] int ) : ()



-- fun external addw(x:arr[4] complex16, y:arr[4] complex16, z:arr[4] complex16 ) : ()
-- c := a + b
fun external v_add_complex16(c:arr complex16, a:arr[length(c)] complex16, b:arr[length(c)] complex16 ) : ()
fun external v_add_complex32(c:arr complex32, a:arr[length(c)] complex32, b:arr[length(c)] complex32 ) : ()
fun external v_add_int16(c:arr int16, a:arr[length(c)] int16, b:arr[length(c)] int16 ) : ()
fun external v_add_int32(c:arr int32, a:arr[length(c)] int32, b:arr[length(c)] int32 ) : ()

-- c := a - b
fun external v_sub_complex16(c:arr complex16, a:arr[length(c)] complex16, b:arr[length(c)] complex16 ) : ()
fun external v_sub_complex32(c:arr complex32, a:arr[length(c)] complex32, b:arr[length(c)] complex32 ) : ()
fun external v_sub_int16(c:arr int16, a:arr[length(c)] int16, b:arr[length(c)] int16 ) : ()
fun external v_sub_int32(c:arr int32, a:arr[length(c)] int32, b:arr[length(c)] int32 ) : ()

-- c := a * b, NB: c is also complex16
fun external v_mul_complex16(c:arr complex16, a:arr[length(c)] complex16, b:arr[length(c)] complex16 ) : ()



-- z := x >> shift
fun external v_shift_right_complex32(z:arr complex32, x:arr[length(z)] complex32, shift:int ) : ()
fun external v_shift_right_complex16(z:arr complex16, x:arr[length(z)] complex16, shift:int ) : ()
fun external v_shift_right_int32(z:arr int32, x:arr[length(z)] int32, shift:int ) : ()
fun external v_shift_right_int16(z:arr int16, x:arr[length(z)] int16, shift:int ) : ()
-- z := x << shift
fun external v_shift_left_complex32(z:arr complex32, x:arr[length(z)] complex32, shift:int ) : ()
fun external v_shift_left_complex16(z:arr complex16, x:arr[length(z)] complex16, shift:int ) : ()
fun external v_shift_left_int32(z:arr int32, x:arr[length(z)] int32, shift:int ) : ()
fun external v_shift_left_int16(z:arr int16, x:arr[length(z)] int16, shift:int ) : ()






-- Set array to zero
fun external zero_bit(x:arr bit) : ()
fun external zero_complex8(x:arr complex8) : ()
fun external zero_complex16(x:arr complex16) : ()
fun external zero_complex32(x:arr complex32) : ()
fun external zero_int8(x:arr int8) : ()
fun external zero_int16(x:arr int16) : ()
fun external zero_int32(x:arr int32) : ()

-- Copy subarray
-- Equivalent to memcpy in C
-- NB: When len is constant, this can be done with dst[0,len] := src[0,len]
-- But this doesn't work for dynamic len
-- NOTE: copy_bit is not trivial to write. TBD
fun external copy_complex8(dst:arr complex8, src:arr complex8, len:int) : ()
fun external copy_complex16(dst:arr complex16, src:arr complex16, len:int) : ()
fun external copy_complex32(dst:arr complex32, src:arr complex32, len:int) : ()
fun external copy_int8(dst:arr int8, src:arr int8, len:int) : ()
fun external copy_int16(dst:arr int16, src:arr int16, len:int) : ()
fun external copy_int32(dst:arr int32, src:arr int32, len:int) : ()

-- Conversions
fun external bits_to_int8(dst: arr int8, src:arr bit) : ()
fun external int8_to_bits(dst: arr bit, src:arr int8) : ()

-- Output
fun external hexprint_int8(a : arr int8, length : int) : ()


-- Various packings
-- Pack two int32 arrays into int16 array
fun external v_pack_int32_complex16(z:arr complex16, x:arr[length(z)] int32, y:arr[length(z)] int32) : ()
fun external v_pack_complex16_complex8(input:arr complex16) : arr[length(input)] complex8


-- Negate
fun external v_negate_complex8(input:arr complex8) : arr[length(input)] complex8



-- Sign operations (essentially applies _mm_sign_epi8)
fun external v_sign_int8(input1 : arr int8, input2 : arr[length(input1)] int8) : arr[length(input1)] int8



-- Cast
fun external v_cast_complex8_int8(output:arr int8, input:arr complex8) : ()


-- Bit manipulation

fun external v_or(input1 : arr bit, input2 : arr[length(input1)] bit) : arr[length(input1)] bit
fun external v_and(input1 : arr bit, input2 : arr[length(input1)] bit) : arr[length(input1)] bit
fun external v_andnot(input1 : arr bit, input2 : arr[length(input1)] bit) : arr[length(input1)] bit
fun external v_xor(input1 : arr bit, input2 : arr[length(input1)] bit) : arr[length(input1)] bit



------ SORA Code:

-- FFT
--fun external sora_ifft(nFFTSize : int16, inp : arr complex16, out : arr [length(inp)] complex16) : ()
--fun external sora_fft(nFFTSize : int16, inp : arr complex16, out : arr [length(inp)] complex16) : ()
fun external sora_ifft(inp : arr complex16) : arr [length(inp)] complex16
fun external sora_fft(inp : arr complex16) : arr [length(inp)] complex16

-- Same as above, as it operates on subarray of inp/outp, so useful for dynamically sized arrays
fun external sora_ifft_dynamic(nFFTSize : int16, inp : arr complex16) : arr [length(inp)] complex16
fun external sora_fft_dynamic(nFFTSize : int16, inp : arr complex16) : arr [length(inp)] complex16



-- Do we still need this?
-- Viterbi
-- setting max frame size for now
fun external viterbi_init(frame_length:int): ()
-- const1 and const2 are used to distinguish between PLCP and data
fun external viterbi_decode(svalue:arr[48] int16, code_rate:int,
             bitValue:arr[96000] bit, const1:int16, const2:int16): int16
fun external viterbi_decode_old(intInput:arr[48] int16, code_rate:int16, out:arr[12000] int16) : int16
--fun external viterbi_decode_sig11a(svalue:arr[48] int, code_rate:int, bitValue:arr[12000] int): int

-- softBits could be dynamic based nBPSC
fun external qpsk_demap(input_sample:complex16, softBits:arr[6] int16) : ()
fun external bpsk_demap(input_sample:complex16) : int16
fun external qam16_demap(input_sample:complex16, softBits:arr[6] int16) : ()
fun external qam64_demap(input_sample:complex16, softBits:arr[6] int16) : ()

-- Brick interface
fun external viterbi_brick_init(frame_length:int, code_rate:int16): ()
fun external viterbiSig11a_brick_init(frame_length:int, code_rate:int16): ()
fun external viterbi_brick_decode(svalue:arr[48] int8, bitValue:arr[96000] bit): int16

-- Fast version which use MSR-LA license
fun external viterbi_brick_init_fast(frame_length:int, code_rate:int16, depth:int16): ()
fun external viterbi_brick_decode_fast(svalue:arr[48] int8, bitValue:arr bit): int16
fun external viterbiSig11a_brick_decode_fast(svalue:arr[48] int8, bitValue:arr bit): int16


-- DbgPlot library (works only in 32-bit mode)
fun external dbgplot_real_line(data: arr int16) : ()
fun external dbgplot_real_line32(data: arr int32) : ()
fun external dbgplot_complex_line(data:arr complex16, type:int16) : ()
fun external dbgplot_spectrum(item:arr complex16) : ()
fun external dbgplot_dots(data:arr complex16) : ()
fun external dbgplot_dot(data:complex16) : ()


-- Time-related
fun external print_time() : ()

-- Start recording time
fun external record_time_start() : ()
-- Print time elapsed in (ns) since last record_time_start()
fun external record_time_stop() : ()

-- Populate a bit array with random stuff
fun external populate_rand_array(arr : arr bit) : ()
# 23 "../parsePLCPHeader.blk" 2
# 1 "../../const.blk" 1
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--

       

let CR_12 = 0
let CR_23 = 1
let CR_34 = 2

let norm_shift = 8

let bpsk_mod_11a = 10720
let qpsk_mod_11a = int16(double(bpsk_mod_11a) / 1.414) -- divided by sqrt(2)
let qam16_mod_11a = int16(double(bpsk_mod_11a) / 3.162) -- divided by sqrt(10)
let qam64_mod_11a = int16(double(bpsk_mod_11a) / 6.481) -- divided by sqrt(42)


--let cca_energy_threshold = 5000
let cca_energy_threshold = 200


let M_BPSK = 0
let M_QPSK = 1
let M_16QAM = 2
let M_64QAM = 3


{-
let amp = 1 -- 1/sqrt(2)
let signalAmplitude = 1000
let QPSKAmp = 707
-}

struct CCAParams = {
  noSamples:int32; -- Total number of samples read from the start of CCA
  shift:int16; -- Shift within 16 samples at which the peak was detected
  energy:int32; -- Preamble energy calculated using calcEnergy() from CCA
  noise:int32; -- Noise energy calculated using calcEnergy() from CCA
  maxCorr:int32 -- Value of correlation that triggered CCA
}

struct LTECoeffs = {
  freqCoeffs:arr[64] complex16;
  channelCoeffs:arr[64] complex16 }

struct HeaderInfo = {
  coding:int32;
  modulation:int32;
  len:int32;
  err:bool -- Any kind of header parsing error (parity bit wrong, reserved bits non-zero)
}



-- Demodulation tables

let m_bpsk_lut = {
 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3}



let m_qam16_lut2 = {
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 4, 4,
 3, 3, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 3,
 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}



let m_qam64_lut2 = {
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 4, 3, 3,
 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2,
 2, 3, 3, 4, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}



let m_qam64_lut3 = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 3, 4,
 4, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 4, 4, 3, 3, 2,
 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5,
 4, 4, 3, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
# 24 "../parsePLCPHeader.blk" 2


fun printHeader(h : struct HeaderInfo) {
  print "Header - modulation: ";
  if (h.modulation == M_BPSK) then {
    print "BPSK";
  } else { if (h.modulation == M_QPSK) then {
    print "M_QPSK";
  } else { if (h.modulation == M_16QAM) then {
    print "16QAM";
  } else {
    print "64QAM";
  } } }
  print ", coding: ";
  if (h.coding == CR_12) then {
    print "1/2";
  } else { if (h.coding == CR_23) then {
    print "2/3";
  } else {
    print "3/4";
  } }
  println ", length: ", h.len, " B";
}


fun createPLCPHeader(h:struct HeaderInfo) {
var hdata:arr[24] bit;
var ai : arr[2] int8;
var ab : arr[16] bit;
var p : bit;

  -- Rate
  if h.modulation == M_BPSK && h.coding == CR_12 then {
    hdata[0,4] := {'1, '1, '0, '1};
  } else {
    if h.modulation == M_BPSK && h.coding == CR_34 then {
       hdata[0,4] := {'1, '1, '1, '1};
    } else {
      if h.modulation == M_QPSK && h.coding == CR_12 then {
         hdata[0,4] := {'0, '1, '0, '1};
      } else {
        if h.modulation == M_QPSK && h.coding == CR_34 then {
           hdata[0,4] := {'0, '1, '1, '1};
        } else {
          if h.modulation == M_16QAM && h.coding == CR_12 then {
             hdata[0,4] := {'1, '0, '0, '1};
          } else {
            if h.modulation == M_16QAM && h.coding == CR_34 then {
               hdata[0,4] := {'1, '0, '1, '1};
            } else {
              if h.modulation == M_64QAM && h.coding == CR_23 then {
                 hdata[0,4] := {'0, '0, '0, '1};
              } else {
                if h.modulation == M_64QAM && h.coding == CR_34 then {
                   hdata[0,4] := {'0, '0, '1, '1};
                } else {
                   -- Default: BPSK, 1/2
                   hdata[0,4] := {'1, '1, '0, '1};
                }
              }
            }
          }
        }
      }
    }
  }

  -- Reserved
  hdata[4] := '0;

  -- Length
  ai[0] := int8(h.len % 256);
  ai[1] := int8(h.len / 256);
  int8_to_bits(ab, ai);
  hdata[5, 12] := ab[0, 12];

  -- Padding
  hdata[17,7] := {'0, '0, '0, '0, '0, '0, '0};

  -- Calculate header's parity
  p := '0;
  for i in [0, 3] {
    let a = hdata[i*8, 8];
    for j in [0, 8] {
      p := p & a[j];
    }
  }
  hdata[17] := hdata[17] ^ p;

  return hdata;
}




fun parsePLCPHeader(hdata:arr[24] bit) {
var b:int;
var h:struct HeaderInfo;
var p : bit;

     if hdata[0] == '1 && hdata[1] == '1 && hdata[2] == '0 && hdata[3] == '1 then { -- 1
       h.modulation := M_BPSK; h.coding := CR_12
     } else {
       if hdata[0] == '1 && hdata[1] == '1 && hdata[2] == '1 && hdata[3] == '1 then { -- 2
         h.modulation := M_BPSK; h.coding := CR_34
       } else {
          if hdata[0] == '0 && hdata[1] == '1 && hdata[2] == '0 && hdata[3] == '1 then { --3
            h.modulation := M_QPSK; h.coding := CR_12
          } else {
               if hdata[0] == '0 && hdata[1] == '1 && hdata[2] == '1 && hdata[3] == '1 then { -- 4
                 h.modulation := M_QPSK; h.coding := CR_34
               } else {
                  if hdata[0] == '1 && hdata[1] == '0 && hdata[2] == '0 && hdata[3] == '1 then { -- 5
                    h.modulation := M_16QAM; h.coding := CR_12
                  } else {
                     if hdata[0] == '1 && hdata[1] == '0 && hdata[2] == '1 && hdata[3] == '1 then { -- 6
                       h.modulation := M_16QAM; h.coding := CR_34
                     } else {
                       if hdata[0] == '0 && hdata[1] == '0 && hdata[2] == '0 && hdata[3] == '1 then { -- 7
                         h.modulation := M_64QAM; h.coding := CR_23
                       } else {
                         if hdata[0] == '0 && hdata[1] == '0 && hdata[2] == '1 && hdata[3] == '1 then { -- 8
                           h.modulation := M_64QAM; h.coding := CR_34
                         } else {
                            h.modulation := M_BPSK; h.coding := CR_12
                         }
                       }
                     }
                  }
               }
            }
       }
     }



     b := 1;
     h.len := 0;
     for j in [5,12] {
       if hdata[j] == '1 then {
         h.len := h.len + b
       };
       b := 2*b
     };

     h.err := false;

     -- Sanity check - no packet larger than 2048B
     if (h.len > 2048) then {
       h.err := true;
       h.len := 2048;
     }

     -- Check header's parity
     p := '0;
     for i in [0, 3] {
       let a = hdata[i*8, 8];
       for j in [0, 8] {
         p := p ^ a[j];
       }
     }

     if (p != '0) then {
       h.err := true;
       -- Don't print wrong packets
       -- println "Header parity check failed!";
     }

     -- Check header's tail
     p := '0;
     let a = hdata[16, 8];
     for j in [2, 6] {
         p := p | a[j];
     }
     if (p != '0) then {
       h.err := true;
       -- Don't print wrong packets
       -- println "Header tail non-zero!";
     }


     if (not h.err) then {
       printHeader(h);
       println "Header bits: ", hdata
     }


  return h;
}


fun comp emitHeader() {
  seq{
    (x : arr[24] bit) <- takes 24;
    emits x;
    return parsePLCPHeader(x)
  }
}
# 24 "test_tx_header.blk" 2
# 1 "../encoding.blk" 1
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--
       



fun comp encode34() {
 var s:arr[6] bit := {'0, '0, '0, '0, '0, '0};
 var x:bit;
 var oA:bit;
 var oB:bit;


 fun enc_state_machine(b:bit) {
   var r:arr[2] bit;
   r[0] := b ^ s[1] ^ s[2] ^ s[4] ^ s[5];
   r[1] := b ^ s[0] ^ s[1] ^ s[2] ^ s[5];

   s[1:5] := s[0:4];
   s[0] := b;
   return r
 } in

-- This is too big for LUTter as we take three times
-- and it gets inlined
-- repeat [12,8] seq{
repeat [6,8] seq{
   dvm1 <- take;
   dvm2 <- take;
   dvm3 <- take;

   emits(enc_state_machine(dvm1));

   let r2 = enc_state_machine(dvm2) in
   emit (r2[0]);
   let r3 = enc_state_machine(dvm3) in
   emit (r3[1])
 }
}


fun comp encode23() {
 var s:arr[6] bit := {'0, '0, '0, '0, '0, '0};
 var x:bit;
 var oA:bit;
 var oB:bit;

 fun enc_state_machine(b:bit) {
   var r:arr[2] bit;
   r[0] := b ^ s[1] ^ s[2] ^ s[4] ^ s[5];
    r[1] := b ^ s[0] ^ s[1] ^ s[2] ^ s[5];

   s[1:5] := s[0:4];
   s[0] := b;
   return r
 } in

-- This is too big for LUTter as we take twice
-- and it gets inlined, so this becomes [16,24]
-- repeat [8,12] seq{
 repeat [8,12] seq{
   dvm1 <- take;
   dvm2 <- take;

   emits (enc_state_machine(dvm1));

   let r2 = enc_state_machine(dvm2) in
   emit r2[0]

 }


}

fun comp encode12() {
 var s:arr[6] bit := {'0, '0, '0, '0, '0, '0};
 var x:bit;
 var oA:bit;
 var oB:bit;

 fun enc_state_machine(b:bit) {
   var r:arr[2] bit;
   r[0] := b ^ s[1] ^ s[2] ^ s[4] ^ s[5];
   r[1] := b ^ s[0] ^ s[1] ^ s[2] ^ s[5];

   s[1:5] := s[0:4];
   s[0] := b;
   return r
 } in

 repeat <= [8,16] seq {
   dvm1 <- take;
   emits (enc_state_machine(dvm1))
 }
}





fun comp encode(coding: int) {
 if coding == CR_34 then
   encode34()
 else
   if coding == CR_23 then
      encode23()
   else
     if coding == CR_12 then
      encode12()
     else
       repeat do{error "Unknown coding rate!"}
}
# 25 "test_tx_header.blk" 2
# 1 "../interleaving.blk" 1
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--
       


# 1 "/cygdrive/c/Users/t-stsmo/src/Ziria/lib/permutation.blk" 1
--
-- Copyright (c) Microsoft Corporation
-- All rights reserved.
--
-- Licensed under the Apache License, Version 2.0 (the ""License""); you
-- may not use this file except in compliance with the License. You may
-- obtain a copy of the License at
--
-- http:
--
-- THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
-- LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR
-- A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
--
-- See the Apache Version 2.0 License for specific language governing
-- permissions and limitations under the License.
--
--
       



fun perm8(p : arr[8] int, iarr : arr[8] bit, var oarr : arr bit) {
  for i in [0,8] {
    oarr[p[i]] := iarr[i]
  }
}

fun perm_orig(p : arr int, iarr : arr bit) {
  var oarr : arr[length(p)] bit;
  var oarrtmp : arr[length(p)] bit;
  zero_bit(oarr);

  unroll for j in [0,length(p)/8] {
     let p1 = p[j*8,8];
     perm8(p1,iarr[j*8,8],oarr)
  }

  return oarr;
}

-- A different implementation that is slower in non LUT code, but
-- faster in LUT code.

fun perm8_full(p : arr[8] int, iarr : arr[8] bit, var oarr : arr bit) {
  for j in [0,length(oarr)] { -- For each output bit
    oarr[j] := '0;
    for i in [0,8] {
      -- if it corresponds to a permutation
      if (j == p[i]) then { oarr[j] := iarr[i]; }
    };
  }
}

fun perm(p : arr int, iarr : arr bit) {
  var oarr : arr[length(p)] bit;
  var oarrtmp : arr[length(p)] bit;

  zero_bit(oarr);

  unroll for j in [0,length(p)/8] {
     let p1 = p[j*8,8];
     var oarrtmp : arr[length(p)] bit
     perm8_full(p1,iarr[j*8,8],oarrtmp)
     oarr := v_or(oarr,oarrtmp);
  }

  return oarr;
}
# 24 "../interleaving.blk" 2


-- number of encoded bits per subcarrier
fun nBPSC(mod: int) {
  if mod == M_BPSK then { return 1 } else {
  if mod == M_QPSK then { return 2 } else {
  if mod == M_16QAM then { return 4 } else {
  if mod == M_64QAM then { return 6 } else { return -1 }
  }}}
}

fun nCBPS(mod: int) { return nBPSC(mod) * 48 }


fun fuse_perm(p1 : arr int, p2 : arr[length(p1)] int) {
    var p3 : arr[length(p1)] int;
    nounroll for i in [0,length(p1)] {
       p3[i] := p2[p1[i]];
    }
    return p3;
}


fun intlv_perm1(mod : int) {
  var perm : arr[288] int;
  for k in [0,288] {
    perm[k] := nCBPS(mod)/16 * (k%16) + k/16
  };
  return perm
}

fun intlv_perm2(mod: int) {
  var perm: arr[288] int;
  let s = if (mod == M_BPSK) then 1 else nBPSC(mod)/2

  for k in [0,288] {
    perm[k] := s * (k/s) + (k+nCBPS(mod) - (16*k)/nCBPS(mod)) % s
  };
  return perm
}

fun comp interleaver_bpsk() {
  var y : arr[48] bit;
  let nCBPSMod = 48 in
  let ids1 = intlv_perm1(M_BPSK) in
  let ids2 = intlv_perm2(M_BPSK) in
  let ids3 = fuse_perm(ids1,ids2) in

  repeat <= [48,48] {
    (x : arr[48] bit) <- takes 48;

    emits perm(ids3[0,48], x);
  }
}

fun comp interleaver_qpsk() {
  var y : arr[2*48] bit;
  let nCBPSMod = 2*48 in
  let ids1 = intlv_perm1(M_QPSK) in
  let ids2 = intlv_perm2(M_QPSK) in
  let ids3 = fuse_perm(ids1,ids2) in

  repeat <= [96,96] {
    (x : arr[96] bit) <- takes 96;
    emits perm(ids3[0,96], x);
  }
}

fun comp interleaver_m16qam() {
  var y : arr[4*48] bit;
  let nCBPSMod = 4*48 in
  let ids1 = intlv_perm1(M_16QAM) in
  let ids2 = intlv_perm2(M_16QAM) in
  let ids3 = fuse_perm(ids1,ids2) in

  repeat <= [192, 192] {
    (x : arr[192] bit) <- takes 192;
    emits perm(ids3[0,192], x);
  }
}

fun comp interleaver_m64qam() {
  var y : arr[6*48] bit;
  let nCBPSMod = 6*48 in
  let ids1 = intlv_perm1(M_64QAM) in
  let ids2 = intlv_perm2(M_64QAM) in
  let ids3 = fuse_perm(ids1,ids2) in

  repeat <= [288, 288]{
    (x : arr[288] bit) <- takes 288;
    emits perm(ids3[0,288], x);
  }
}

fun comp interleaver(mod: int) {
  if (mod == M_BPSK) then {
     interleaver_bpsk()
  } else {
      if (mod == M_QPSK) then {
          interleaver_qpsk()
      } else {
          if (mod == M_16QAM) then {
             interleaver_m16qam()
          } else { interleaver_m64qam() }
      }
  }
}
# 26 "test_tx_header.blk" 2

let h = HeaderInfo{coding=CR_34; modulation=M_16QAM; len=100; err=false};

let comp main = read[int] >>>
  { emits createPLCPHeader(h)
  ; (emits createPLCPHeader(h) >>> encode12())
  ; (emits createPLCPHeader(h) >>> encode12() >>> interleaver_bpsk())
  } >>> write
