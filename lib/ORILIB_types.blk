struct IO_t_MemWriter_State = { nextWriteOffset : int32 }
--struct IO_t_MemWriter_Conf = { bytes : arr[1] int8; nBytes : int32; nBytesPerSymbol : int32; nWrapArounds : int32 }
--struct ORILIB_t_GainState = { positionE2 : int32; zwinPositionE2 : int32; currWindowEnergyE2_withGain : int32; zwinSampleEnergyTermBuf_withGain: arr[80] int32; currAgcGainBuf : arr[80] int32 }
--struct ORILIB_t_GainStateAux = { windowEnergyE1andE2Buf_withGain : arr[160] int32; currAgcGainBuf arr[80] int32 }
--struct ORILIB_t_Cplx16Buf80 = { samples : arr[80] complex16 }
--struct ORILIB_t_SimpleEnergyState = { zwinPositionE2 : int32; currWindowEnergy : int32; zwinSampleEnergyTermBuf : arr[80] int32; windowEnergyBuf : arr[80] int32 }
--struct ORILIB_t_GPIOConf = { bank : int8; pin : int8; offOnToggle : int8 }
--struct Vitdec_Profile = { rate : int32; constLen : int8; yamTh : int16; stateNum : int8; tbConvrgMode : bool; decision : int8; readFlag : int8; tailBitEnable : bool; traceBackIndex : int16; outOrder : int8; perf : int8; poly0 : int8; poly1 :int8; poly2 : int8; poly3 : int8; c_guess int32; c : int32; frameLen : int16; r : int32; inputBM_frames : int32; outputHD_bytes_rounded : int32; numSymProcExpected : int32 }
--struct VCP2_ConfigIc = { ic0 : int32; ic1 : int32; ic2 : int32; ic3 : int32; ic4 : int32; ic5 : int32}
--enum ORILIB_ViterDecoder_t_VcpInstance = { kVCPI_0; kVCPI_1; kVCPI_2; kVCPI_3 }
--struct ORILIB_t_ViterbiDecoderState = { profile : Vitdec_Profile; config : VCP2_ConfigIc; output_params : int64; which_vcp : ORILIB_ViterDecoder_t_VcpInstance; cword : int32; output_frame_length : int32; num_bits_to_decode : int32; num_bits_decoded : int32}
--enum Vitdec_Mode = { VITDEC_HEADCONVGT; VITDEC_MIDCONVGT; VITDEC_TAILCONVGT; VITDEC_HEADTAIL }
--enum Vitdec_ConvergenceLength = { VITDEC_CL_18 = 18; VITDEC_CL_36 = 36; VITDEC_CL_54 = 54; VITDEC_CL_72 = 72}
--struct ORILIB_t_ViterbiDecoderInitOnceConf = { mode : Vitdec_Mode; which_vcp : ORILIB_ViterDecoder_t_VcpInstance; convergenceLength : Vitdec_ConvergenceLength } 
--struct ORILIB_t_ViterbiDecoderGenConfConf = { mode : Vitdec_Mode; num_bits_to_decode : int32; convergenceLength : Vitdec_ConvergenceLength } 
--struct ORILIB_t_ViterbiDecoderWFCState = { which_vcp : ORILIB_ViterDecoder_t_VcpInstance; numSymProcExpected : int32}
--struct ORILIB_t_ViterbiDecoderWFCConf = { which_vcp : ORILIB_ViterDecoder_t_VcpInstance }
--struct ORILIB_t_SoftBitBuf48 = { softBits : arr[48] int8 }
--struct Vitdec_ViterbiDecodingMap = { n0 : int32; n1 : int32; l1 : int32; d1 : int32; L1 : int32; p1 : int32; q1 : int32; n2 : int32; l2 : int32; d2 : int32; L2 : int32; p2 : int32; q2 : int32; n3 : int32; l3 : int32; d3 : int32; L3 : int32; p3 : int32; q3 : int32; n4 : int32; l4 : int32; d4 : int32; L4 : int32; p4 : int32; q4 : int32; nMidIterations : int32 }
--struct WIFILIB_TxRxPktState = { NumInfoBits : int32; DataRate : int8; ModulationSchemeIndex : int8; NumCodedBitsPerCarrier : int8; CodingRateTimes120 : int8; NumInfoOctets : int16; NumCodedBitsPerSymbol : int16; NumDataBitsPerSymbol : int16; NumDataBytesPerSymbol : int32; NumDataWordsPerSymbol : int32; NumUncodedBits : int32;	NumCodedBits : int32; NumPadBits : int32; NumConstPnts : int32; NumDataSymbols : int32; NumDataSymbolsWithServicePlusDataParts : int32; isSpecialCase : int32; currPktPortion : int32; currSymbolIdx : int32 }
--struct ORILIB_t_ViterbiDecodingMapConf = { frameLength : int32;  convergenceLength : int32}
--struct ORILIB_t_CorrState = { corr_positionNextE2Value : int32; corr_zwinPosition : int32; corr_zwinCorrTermBuf : arr[80] complex16; corr_zwinSampleBuf : arr[80] complex16; corr_currWinCorr : complex16; corr_maxMetricRunLength : int32; corr_maxMetricIsHigh : int32; corr_maxMetricBufIdx : int32; corr_maxMetric : int32; corr_peakFound : int32; debug_magNumerBuf_64 : arr[80] int64; debug_magDenScBuf_64 : arr[80] int64; debug_magNumerBuf : arr[80] int32; debug_magDenomBuf : arr[80] int32; debug_metricBuf : arr[80] int32 }
--struct ORILIB_t_AlignState = { alignedSampleLookbackBuf : arr[384] complex16; nAlignedSamplesAlreadyFilled : int32; nAlignedSamplesAvailable : int32; uaks1 : int32; uaks2 : int32}
--struct ORILIB_t_Offset1 = { byteOffset : int32 }
--struct ORILIB_OFDMModulator_t_State = { pilot_polarity_counter : int8 }
--struct ORILIB_OFDMModulator_InitPerPacket_t_Conf = { pilot_polarity_counter : int32 }
--struct ORILIB_OFDMDemodulator_t_State = { pilot_polarity_counter : int8 }
--struct ORILIB_t_Cplx16Buf48 = { samples : arr[48] complex16 }
--struct ORILIB_t_Cplx16Buf4 = { samples : arr[4] complex16 }
--struct ORILIB_OFDMModulator_t_Conf = { scaleFactor : int32 }
--struct ORILIB_t_ChEstimatorLTF_State = { avgChannelGains : arr[48] complex16; avgChannelGainsConj : arr[48] complex16; hhstar : arr[48] int32; recip_hhstar_frac : arr[48] int16; recip_hhstar_exp : arr[48] int16; recip_hhstarF : arr[48] float; avgChannelGains_Pilots : arr[4] complex16; avgChannelGainsConj_Pilots : arr[4] complex16; hhstar_Pilots : arr[4] int32; recip_hhstar_frac_Pilots : arr[4] int16; recip_hhstar_exp_Pilots : arr[4] int16; recip_hhstarF_Pilots : arr[4] float }
--struct ORILIB_t_Cplx32Buf48 = { samples : arr[48] complex32 }
--struct ORILIB_t_OFDMEqualizer_State = { yhstar_norm_min : int32 }
--struct ORILIB_t_ChEstimatorLTF_Float_State = { avgChannelGains : arr[48] complex16; avgChannelGainsConj : arr[48] complex16; hhstar : arr[48] int32; recip_hhstarF : arr[48] float; avgChannelGains_Pilots : arr[4] complex16; avgChannelGainsConj_Pilots : arr[4] complex16; hhstar_Pilots : arr[4] int32; recip_hhstarF_Pilots : arr[4] float }
--enum ORILIB_t_DataDecodeMode { DATA_DECODE_STATE_INIT; DATA_DECODE_STATE_CACHING_SYMS; DATA_DECODE_STATE_HEADTAIL_DECODING; DATA_DECODE_STATE_HEAD_DECODING; DATA_DECODE_STATE_MID_PRE_DECODING; DATA_DECODE_STATE_MID_DECODING; DATA_DECODE_STATE_TAIL_DECODING; DATA_DECODE_STATE_TAILfHEAD_DECODING; DATA_DECODE_STATE_TAIL_FINISH; DATA_DECODE_STATE_TAILfHEAD_FINISH; DATA_DECODE_STATE_HEAD_DECODING_ONESYMRX; DATA_DECODE_STATE_TAILfHEAD_DECODING_ONESYMRX; DATA_DECODE_STATE_TAILfHEAD_FINISH_ONESYMRX }
--struct ORILIB_t_DataDecodeState = { dataDecodeMode : ORILIB_t_DataDecodeMode}
--struct Decision_t = { nextState : int32; iterCount : int32 }
--struct ORILIB_t_DataDecodeDecisionConf = { transitionMap : arr[12] int32}
--struct ORILIB_t_CorrStateAux = { winCorrBuf : arr[80] complex16}
--struct ORILIB_t_DetectState = { peakFound : int32; agcGain : int32 }
--struct ORILIB_t_CFOState = { phiU : int32; sign_cfo : int32; derot_table_stride : int32; derotTablePtr : arr[1] complex16 }
--struct ORILIB_t_Offset2 = { inpByteOffset : int32; outByteOffset : int32 }
--struct ORILIB_t_Cplx16Buf160 = { samples : arr[160] complex16 }
